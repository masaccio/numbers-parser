# numbers-parser

[![build:](https://github.com/masaccio/numbers-parser/actions/workflows/run-all-tests.yml/badge.svg)](https://github.com/masaccio/numbers-parser/actions/workflows/run-all-tests.yml) [![image1](https://github.com/masaccio/numbers-parser/actions/workflows/codeql.yml/badge.svg)](https://github.com/masaccio/numbers-parser/actions/workflows/codeql.yml) [![codecov](https://codecov.io/gh/masaccio/numbers-parser/branch/main/graph/badge.svg?token=EKIUFGT05E)](https://codecov.io/gh/masaccio/numbers-parser) [![PyPI version](https://badge.fury.io/py/numbers-parser.svg)](https://badge.fury.io/py/numbers-parser)

`numbers-parser` is a Python module for reading and writing [Apple
Numbers](https://www.apple.com/numbers/) `.numbers` files. It
supports Numbers files generated by Numbers version 10.3, and up with
the latest tested version being 13.2 (current as of September 2023).

It supports and is tested against Python versions from 3.8 onwards. It
is not compatible with earlier versions of Python.

## Installation

```bash
python3 -m pip install numbers-parser
```

A pre-requisite for this package is
[python-snappy](https://pypi.org/project/python-snappy/) which will
be installed by Python automatically, but python-snappy also requires
that the binary libraries for snappy compression are present.

The most straightforward way to install the binary dependencies is to
use [Homebrew](https://brew.sh) and source Python from Homebrew
rather than from macOS as described in the [python-snappy
github](https://github.com/andrix/python-snappy):

For Intel Macs:

```bash
brew install snappy python3
CPPFLAGS="-I/usr/local/include -L/usr/local/lib" python3 -m pip install python-snappy
```

For Apple Silicon Macs:

```bash
brew install snappy python3
CPPFLAGS="-I/opt/homebrew/include -L/opt/homebrew/lib" python3 -m pip install python-snappy
```

For Linux (your package manager may be different):

```bash
sudo apt-get -y install libsnappy-dev
```

On Windows, you will need to either arrange for snappy to be found for
VSC++ or you can install python binary libraries compiled by [Christoph
Gohlke](https://www.lfd.uci.edu/~gohlke/pythonlibs/#python-snappy).
You must select the correct python version for your installation. For
example for python 3.11:

```text
C:\Users\Jon>pip install C:\Users\Jon\Downloads\python_snappy-0.6.1-cp311-cp311-win_amd64.whl
```

<a id="api-changes-in-version-40"></a>

## API changes in version 4.0

To better partition cell styles, background image data which was
supported in earlier versions through the methods `image_data` and
`image_filename` is now part of the new `cell_style` property. Using
the deprecated methods `image_data` and `image_filename` will issue
a `DeprecationWarning` if used.The legacy methods will be removed in a
future version of numbers-parser.

`NumberCell` cell values are now limited to 15 significant figures to
match the implementation of floating point numbers in Apple Numbers. For
example, the value `1234567890123456` is rounded to
`1234567890123460` in the same way as in Numbers. Previously, using
native `float` with no checking resulted in rounding errors in
unpacking internal numbers. Attempting to write a number with too many
significant digits results in a `RuntimeWarning`.

The previously deprecated methods `Document.sheets()` and
`Sheet.tables()` are now only available using the properties of the
same name (see examples in this README).

## Usage

Reading documents:

```python
>>> from numbers_parser import Document
>>> doc = Document("mydoc.numbers")
>>> sheets = doc.sheets
>>> tables = sheets[0].tables
>>> rows = tables[0].rows()
```

Sheets and tables are iterables that can be indexed using either an integer index or using the name of the sheet/table:

```python
>>> doc.sheets[0].name
'Sheet 1'
>>> doc.sheets["Sheet 1"].name
'Sheet 1'
>>> doc.sheets[0].tables[0].name
'Table 1'
>>> doc.sheets[0].tables["Table 1"].name
'Table 1'
```

### Accessing data

`Table` objects have a `rows` method which contains a nested list
with an entry for each row of the table. Each row is itself a list of
the column values.

```python
data = sheets["Table 1"].rows()
print("Cell A1 contains", data[0][0])
print("Cell C2 contains", data[2][1])
```

Cells are objects with a common base class of `Cell`. All cell types
have a property `value` which returns the contents of the cell in as a
python datatype. `numbers-parser` uses
[pendulum](https://pendulum.eustace.io) instead of python’s builtin
types. Available cell types are:

| Cell type    | value type          | Additional properties                           |
|--------------|---------------------|-------------------------------------------------|
| NumberCell   | `float`             |                                                 |
| TextCell     | `str`               |                                                 |
| RichTextCell | `str`               | See [Bullets and<br/>lists](#bullets-and-lists) |
| EmptyCell    | `None`              |                                                 |
| BoolCell     | `bool`              |                                                 |
| DateCell     | `pendulum.datetime` |                                                 |
| DurationCell | `pendulum.duration` |                                                 |
| ErrorCell    | `None`              |                                                 |
| MergedCell   | `None`              | See [Merged<br/>cells](#merged-cells)           |

Where cell values are not `None` the property `formatted_value`
returns the cell value as a `str` as displayed in Numbers. Cells that
have no values in a table are represented as `EmptyCell` and cells
containing evaluation errors of any kind `ErrorCell`.

### Cell references

Data for single cells is accessed using `Table.cell()`. Cell references can be
references can be either zero-offset row/column integers or an Excel/Numbers cell reference
using a column letter and row number.

### Row and column iterators

Tables have iterators for row-wise and column-wise iteration with each
iterator returning a list of the cells in that row or column

```python
for row in table.iter_rows(min_row=2, max_row=7, values_only=True):
    sum += row
for col in table.iter_cols(min_row=2, max_row=7):
    sum += col.value
```

### Formulas

Formula evaluation relies on Numbers storing current values which should
usually be the case. In cells containing a formula, `value` returns
the computed value of the formula. The formula itself is available using
the `formula` property.

### Pandas

Since the return value of `rows()` is a list of lists, you can pass
this directly to pandas. Assuming you have a Numbers table with a single
header which contains the names of the pandas series you want to create
you can construct a pandas dataframe using:

```python
import pandas as pd

doc = Document("simple.numbers")
sheets = doc.sheets
tables = sheets[0].tables
data = tables[0].rows(values_only=True)
df = pd.DataFrame(data[1:], columns=data[0])
```

### Bullets and lists

Cells that contain bulleted or numbered lists can be identified by the
`is_bulleted` property. Data from such cells is returned using the
`value` property as with other cells, but can additionally extracted
using the `bullets` property. `bullets` returns a list of the
paragraphs in the cell without the bullet or numbering character.
Newlines are not included when bullet lists are extracted using
`bullets`.

```python
doc = Document("bullets.numbers")
sheets = doc.sheets
tables = sheets[0].tables
table = tables[0]
if not table.cell(0, 1).is_bulleted:
    print(table.cell(0, 1).value)
else:
    bullets = ["* " + s for s in table.cell(0, 1).bullets]
    print("\n".join(bullets))
```

Bulleted and numbered data can also be extracted with the bullet or
number characters present in the text for each line in the cell in the
same way as above but using the `formatted_bullets` property. A single
space is inserted between the bullet character and the text string and
in the case of bullets, this will be the Unicode character seen in
Numbers, for example `"• some text"`.

### Hyperlinks

Numbers does not support hyperlinks to cells within a spreadsheet, but
does allow embedding links in cells. When cells contain hyperlinks,
`numbers_parser` returns the text version of the cell. The
`hyperlinks` property of cells where `is_bulleted` is `True` is a
list of text and URL tuples:

```python
cell = table.cell(0, 0)
(text, url) = cell.hyperlinks[0]
```

### Styles

`numbers_parser` currently only supports paragraph styles and cell
styles. The following paragraph styles are supported:

- font attributes: bold, italic, underline, strikethrough
- font selection and size
- text foreground color
- horizontal and vertical alignment
- cell background color
- cell indents (first line, left, right, and text inset)

Table styles that allow new tables to adopt a style across the whole
table are not planned.

Numbers conflates style attributes that can be stored in paragraph
styles (the style menu in the text panel) with the settings that are
available on the Style tab of the Text panel. Some attributes in Numbers
are not applied to new cells when a style is applied. To keep the API
simple, `numbers-parser` packs all styling into a single `Style`
object. When a document is saved, the attributes not stored in a
paragraph style are applied to each cell that includes it. Attributes
behaving in this way are currently `Cell.alignment.vertical` and
`Cell.style.text_inset`. The cell background color
`Cell.style.bg_color` also behaves this way, though this is in line
with the separation in Numbers.

#### Reading styles

The cell method `style` returns a `Style` object containing all the
style information for that cell. Cells with identical style settings
contain references to a single style object.

Cell style attributes can be returned using a number of methods:

- `Cell.style.alignment`: the horizontal and vertical alignment of
  the cell as an `Alignment` names tuple
- `Cell.style.bg_color`: cell background color as an `RGB` named
  tuple, or a list of `RGB` values for gradients
- `Cell.style.bold`: `True` if the cell font is bold
- `Cell.style.font_color`: font color as an `RGB` named tuple
- `Cell.style.font_size`: font size in points (`float`)
- `Cell.style.font_name`: font name (`str`)
- `Cell.style.italic`: `True` if the cell font is italic
- `Cell.style.name`: cell style (`str`)
- `Cell.style.underline`: `True` if the cell font is underline
- `Cell.style.strikethrough`: `True` if the cell font is
  strikethrough
- `Cell.style.first_indent`: first line indent in points (`float`)
- `Cell.style.left_indent`: left indent in points (`float`)
- `Cell.style.right_indent`: right indent in points (`float`)
- `Cell.style.text_inset`: text inset in points (`float`)
- `Cell.style.text_wrap`: `True` if text wrapping is enabled
  (default for new cells)

#### Cell images

The methods `style.bg_image.filename` and `style.bg_image.data`
return data about the image used for a cell’s background, where set. If
a cell has no background image, `style.bg_image` is `None`.

```python
cell = table.cell("B1")
with open (cell.style.bg_image.filename, "wb") as f:
    f.write(cell.style.bg_image.data)
```

Due to a limitation in Python’s
[ZipFile](https://docs.python.org/3/library/zipfile.html), Python
versions older than 3.11 do not support image filenames with UTF-8
characters (see [issue
69](https://github.com/masaccio/numbers-parser/issues/69)).
`cell.style.bg_image` returns `None` for such files and issues a
`RuntimeWarning`.

### Formatting

Numbers has two different cell formatting types: data formats and custom
formats.

Data formats are presented in Numbers in the Cell tab of the Format pane
and are applied to individual cells. Like Numbers, `numbers-parsers`
caches formatting information that is identical across multiple cells.
Users of the `numbers-parsers` do not need to take any action for this
to happen; this is handled internally by the package. Changing a data
format for cell has no impact on any other cells.

Custom formats are shared across a Document and can be applied to
multiple cells in multiple tables. Editing a custom format changes the
appearance of data in all cells that share that format.

The data representation of all cells is read uding the
`formatted_value` property of the `Cell` object. This property
returns a `str` value identical to that displayed visually by Numbers.

A limited number of currencies are formatted using symbolic notation
rather than an ISO code. These are defined in
`numbers_parser.currencies` and match the ones chosen by Numbers. For
example, US dollars are referred to as `US$` whereas Euros and British
Pounds are referred to using their symbols of `€` and `£`
respectively.

#### Writing Data Formats

The `Table` method `set_cell_formatting()` sets the formatting for a
single cell:

```python
table.set_cell_formatting("C1", "date", date_time_format="EEEE, d MMMM yyyy")
table.set_cell_formatting(0, 4, "number", decimal_places=3, negative_style=NegativeNumberStyle.RED)
```

The positional parameter after the cell reference is the type of data
format to apply to the cell. Applying an incompatble data format to a
cell, for example a date format to a `TextCell` or a `NumberCell`
raises `TypeError` exception. Each data format has its own set of
key-value pairs to configure the available parameters:

<!-- markdownlint-disable MD033 --><table>
    <thead>
        <tr>
            <th>Data Format</th>
            <th>Parameter</th>
            <th>Description</th>
            <th>Default</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=3><code>base</code></td>
            <td><code>base</code></td>
            <td>The integer base to represent the number from 2-36.</td>
            <td><code>10</code>
        </tr>
        <tr>
            <td><code>base_use_minus_sign</code></td>
            <td>If <code>True</code> use a standard minus sign, otherwise format as two's compliment (only possible for binary, octal and hexadecimal</td>
            <td><code>True</code></td>
        </tr>
        <tr>
            <td><code>base_places</code></td>
            <td>The number of decimal places, or <code>None</code> for automatic</td>
            <td><code>0</code></td>
        </tr>
        <tr>
            <td rowspan=5><code>currency</code></td>
            <td><code>currency_code</code></td>
            <td>An ISO currency code, e.g. <code>GBP</code> or <code>USD</code></td>
            <td><code>GBP</code> regardless of locale</td>
        </tr>
        <tr>
            <td><code>decimal_places</code></td>
            <td>The number of decimal places, or <code>None</code> for automatic</td>
            <td><code>2</code></td>
        </tr>
        <tr>
            <td><code>negative_style</code></td>
            <td>How negative numbers are represented defined by the <code>NegativeNumberStyle</code> enum</td>
            <td><code>NegativeNumberStyle.MINUS</code></td>
        </tr>
        <tr>
            <td><code>show_thousands_separator</code></td>
            <td><code>True</code> if the number should include a thousands seperator, e.g. <code>,</code></td>
            <td><code>False</code></td>
        </tr>
        <tr>
            <td><code>use_accounting_style</code></td>
            <td><code>True</code> if the currency symbol should be formatted to the left of the cell and separated from the number value by a tab. A <code>RuntimeWarning</code> is generated if this is combined with <code>negative_style</code>.</td>
            <td><code>False</code></td>
        </tr>
        <tr>
            <td><code>datetime</code></td>
            <td><code>date_time_format</code></td>
            <td>A POSIX <code>strftime</code>-like formatting string. See <a href="#datetime-formatting">Date/time formatting</a> for a list of supported directives</td>
            <td><code>dd MMM YYY HH:MM</code></td>
        </tr>
        <tr>
            <td><code>fraction</code></td>
            <td><code>fraction_accuracy</code></td>
            <td>The precision of the faction defined by the \`FractionAccuracy\` enum</td>
            <td><code>FractionAccuracy.THREE</code></td>
        </tr>
        <tr>
            <td rowspan=3><code>percentage</code></td>
            <td><code>decimal_places</code></td>
            <td>The number of decimal places, or <code>None</code> for automatic</td>
            <td><code>Auto</code></td>
        </tr>
        <tr>
            <td><code>negative_style</code></td>
            <td>How negative numbers are represented defined by the <code>NegativeNumberStyle</code> enum</td>
            <td><code>NegativeNumberStyle.MINUS</code></td>
        </tr>
        <tr>
            <td><code>show_thousands_separator</code></td>
            <td><code>True</code> if the number should include a thousands seperator, e.g. <code>,</code></td>
            <td><code>False</code><td>
        </tr>
        <tr>
            <td rowspan=3><code>number</code></td>
            <td><code>decimal_places</code></td>
            <td>The number of decimal places, or <code>None</code> for automatic</td>
            <td><code>Auto</code><td>
        </tr>
        <tr>
            <td><code>negative_style</code></td>
            <td>How negative numbers are represented defined by the <code>NegativeNumberStyle</code> enum</td>
            <td><code>NegativeNumberStyle.MINUS</code></td>
        </tr>
        <tr>
            <td><code>show_thousands_separator</code></td>
            <td><code>True</code> if the number should include a thousands seperator, e.g. <code>,</code></td>
            <td><code>False</code><td>
        </tr>
        <tr>
            <td><code>scientific</code></td>
            <td><code>decimal_places</code></td>
            <td>The number of decimal places, or <code>None</code> for automatic</td>
            <td><code>Auto</code><td>
        </tr>
    </tbody>
</table>
<!-- markdownlint-enable MD033 -->

##### Date/time formatting

`date_time_format` uses Numbers notation for date and time formatting
rather than POSIX `strftime` as there are a number of extensions. Date
components are specified using directives which must be separated by
whitespace. Supported directives are:

| Directive   | Meaning                                                               | Example              |
|-------------|-----------------------------------------------------------------------|----------------------|
| `a`         | Locale’s AM or PM                                                     | am, pm               |
| `EEEE`      | Full weekday name                                                     | Monday, Tuesday, …   |
| `EEE`       | Abbreviated weekday name                                              | Mon, Tue, …          |
| `yyyy`      | Year with century as a<br/>decimal number                             | 1999, 2023, etc.     |
| `yy`        | Year without century as a<br/>zero-padded decimal<br/>number          | 00, 01, … 99         |
| `y`         | Year without century as a<br/>decimal number                          | 0, 1, … 99           |
| `MMMM`      | Full month name                                                       | January, February, … |
| `MMM`       | Abbreviated month name                                                | Jan, Feb, …          |
| `MM`        | Month as a zero-padded<br/>decimal number                             | 01, 02, … 12         |
| `M`         | Month as a decimal number                                             | 1, 2, … 12           |
| `d`         | Day as a decimal number                                               | 1, 2, … 31           |
| `dd`        | Day as a zero-padded<br/>decimal number                               | 01, 02, … 31         |
| `DDD`       | Day of the year as a<br/>zero-padded 3-digit<br/>number               | 001 - 366            |
| `DD`        | Day of the year as a<br/>minimum zero-padded<br/>2-digit number       | 01 - 366             |
| `D`         | Day of the year                                                       | 1 - 366              |
| `HH`        | Hour (24-hour clock) as a<br/>zero-padded decimal<br/>number          | 00, 01, … 23         |
| `H`         | Hour (24-hour clock) as a<br/>decimal number                          | 0, 1, … 23           |
| `hh`        | Hour (12-hour clock) as a<br/>zero-padded decimal<br/>number          | 01, 02, … 12         |
| `h`         | Hour (12-hour clock) as a<br/>decimal number                          | 1, 2, … 12           |
| `k`         | Hour (24-hour clock) as a<br/>decimal number to 24                    | 1, 2, … 24           |
| `kk`        | Hour (24-hour clock) as a<br/>zero-padded decimal<br/>number to 24    | 01, 02, … 24         |
| `K`         | Hour (12-hour clock) as a<br/>decimal number from 0                   | 0, 1, … 11           |
| `KK`        | Hour (12-hour clock) as a<br/>zero-padded decimal<br/>number from 0   | 00, 01, … 11         |
| `mm`        | Minutes as a zero-padded<br/>number                                   | 00, 01, … 59         |
| `m`         | Minutes as a number                                                   | 0, 1, … 59           |
| `ss`        | Seconds as a zero-padded<br/>number                                   | 00, 01, … 59         |
| `s`         | Seconds as a number                                                   | 0, 1, … 59           |
| `W`         | Week number in the month<br/>(first week is zero)                     | 0, 1, … 5            |
| `ww`        | Week number of the year<br/>(Monday as the first day<br/>of the week) | 0, 1, … 53           |
| `G`         | AD or BC (only AD is<br/>supported)                                   | AD                   |
| `F`         | How many times the day of<br/>falls in the month                      | 1, 2, … 5            |
| `S`         | Seconds to one decimal<br/>place                                      | 0 - 9                |
| `SS`        | Seconds to two decimal<br/>places                                     | 00 - 99              |
| `SSS`       | Seconds to three decimal<br/>places                                   | 000 - 999            |
| `SSSS`      | Seconds to four decimal<br/>places                                    | 0000 - 9999          |
| `SSSSS`     | Seconds to five decimal<br/>places                                    | 00000 - 9999         |

##### Negative number formatting

Where supported by a data format, `negative_style` must be a valid
`NegativeNumberStyle` enum. Supported values are:

<!-- markdownlint-disable MD033 -->

| Value                 | Examples   |
|-----------------------|------------|
| `MINUS`               | -1234.560  |
| `RED`                 | 1234.560   |
| `PARENTHESES`         | (1234.560) |
| `RED_AND_PARENTHESES` | (1234.560) |
<!-- markdownlint-enable MD033 -->

#### Writing Custom Data Formats

The `Document` method `add_custom_format()` creates a custom format
and returns a `CustomFormatting` object. Custom formatting is applied
to cells using the `Table` method `set_cell_formatting` in a similar
way to data formats:

```python
long_date = doc.add_custom_format(name="Long Date", type="date", date_time_format="EEEE, d MMMM yyyy")
table.set_cell_formatting("C1", "custom", format=long_date)
```

`add_custom_format` takes a list of key-value pairs as follows
defining the format.

- `name` is the name of the custom format. If no name is provided,
  one is generated using the scheme `Custom Format`,
  `Custom Format 1`, `Custom Format 2`, etc.
- `type` is the type of format to create. Supported formats are
  `number`, `datetime` and `text`. If no type is provided,
  `add_custom_format` defaults to `number`

In addition to these basic parameters, `add_custom_format` also
supports the following parameters dependent upon format type:

<!-- markdownlint-disable MD033 --><table>
    <thead>
        <tr>
            <th>Format Type</th>
            <th>Parameter</th>
            <th>Description</th>
            <th>Default</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=5><code>number</code></td>
            <td><code>integer_format</code></td>
            <td>How to pad integers represented defined by the <code>PaddingType</code> enum</td>
            <td><code>PaddingType.NONE</code>
        </tr>
        <tr>
            <td><code>decimal_format</code></td>
            <td>How to pad decimals represented defined by the <code>PaddingType</code> enum</td>
            <td><code>PaddingType.NONE</code>
        </tr>
        <tr>
            <td><code>num_integers</code></td>
            <td>The integer precision when integers are padded</td>
            <td><code>0</code>
        </tr>
        <tr>
            <td><code>num_decimals</code></td>
            <td>The integer precision when decimals are padded</code> enum<</td>
            <td><code>0</code>
        </tr>
        <tr>
            <td><code>show_thousands_separator</code></td>
            <td><code>True</code> if the number should include a thousands seperator, e.g. <code>,</code></td>
            <td><code>False</code></td>
        </tr>
        <tr>
            <td><code>datetime</code></td>
            <td><code>format</code></td>
            <td>A POSIX <code>strftime</code>-like formatting string. See <a href="#datetime-formatting">Date/time formatting</a> for a list of supported directives</td>
            <td><code>d MMM y</code>
        </tr>
        <tr>
            <td><code>text</code></td>
            <td><code>format</code></td>
            <td>A string format where the cell value is inserted in place of <code>%s</code>. Only one substitution is allowed by Numbers, and multiple <code>%s</code> formatting references raise a <code>TypeError</code> exception.</td>
            <td><code>%s</code>
        </tr>
    </tbody>
</table>
<!-- markdownlint-enable MD033 -->

`set_cell_formatting` accepts either a `CustomFormatting` object or
the name of a custom style.

A `dict` of available custom formats is returned by the `Document`
property `custom_formats`. This contains key value pairs of format
names and `CustomFormatting` objects. Any changes to
`CustomFormatting` objects in the document are written back such that
those formats are changed for all cells that use them.

### Borders

`numbers-parser` supports reading and writing cell borders, though the
interface for each differs. Individual cells can have each of their four
borders tested, but when drawing new borders, these are set for the
table to allow for drawing borders across multiple cells. Setting the
border of merged cells is not possible unless the edge of the cells is
at the end of the merged region.

Borders are represented using the `Border` class that can be
initialized with line width, color and line style:

```python
border = Border(4.0, RGB(0, 162, 255), "solid"))
```

Valid values for the line `style` parameter are `"solid"`,
`"dashes"`, `"dots"` and `"none"`.

#### Reading Cell Borders

Cells have a property `border` which itself has the properties
`top`, `right`, `bottom` and `left`, each of which is a
`Border` class representing the line type for that cell. Cells with no
border set at all, and merged cells which are inside the range of the
merge return `None` for these cells. The absence of a specified border
is different from no border in Numbers which is a valid `Border` class
with `style="none"`.

#### Writing Cell Borders

The `Table` method `set_cell_border()` sets the border for a cell
edge or a range of cells:

```python
table.set_cell_border("C1", ["top", "left"], Border(0.0, RGB(0, 0, 0), "none"))
table.set_cell_border(0, 4, "right", Border(1.0, RGB(0, 0, 0), "solid"), 3)
```

The last positional parameter specifies the length of the border and
defaults to 1. A single call to `set_cell_border()` can set the
borders to one or more sides of the cell as above. Like
`Table.write()`, `set_cell_border()` supports both row/column and
Excel/Numbers-style cell references.

## Writing Numbers files

Whilst support for writing numbers files has been stable since version
3.4.0, you are highly recommended not to overwrite working Numbers files
and instead save data to a new file.

### Limitations

Current limitations to write support are:

- Creating cells of type `BulletedTextCell` is not supported
- New tables are inserted with a fixed offset below the last table in a
  worksheet which does not take into account title or caption size
- New sheets insert tables with formats copied from the first table in
  the previous sheet rather than default table formats

### Cell values

`numbers-parser` will automatically empty rows and columns for any
cell references that are out of range of the current table. The
`write` method accepts the same cell numbering notation as `cell`
plus an additional argument representing the new cell value. The type of
the new value will be used to determine the cell type.

```python
doc = Document("old-sheet.numbers")
sheets = doc.sheets
tables = sheets[0].tables
table = tables[0]
table.write(1, 1, "This is new text")
table.write("B7", datetime(2020, 12, 25))
doc.save("new-sheet.numbers")
```

Sheet names and table names can be changed by assigning a new value to
the `name` of each:

```python
sheets[0].name = "My new sheet"
tables[0].name = "Edited table"
```

### Adding tables and sheets

Additional tables and worksheets can be added to a `Document` before
saving. If no sheet name or table name is supplied, `numbers-parser`
will use `Sheet 1`, `Sheet 2`, etc.

```python
doc = Document()
doc.add_sheet("New Sheet", "New Table")
sheet = doc.sheets["New Sheet"]
table = sheet.tables["New Table"]
table.write(1, 1, 1000)
table.write(1, 2, 2000)
table.write(1, 3, 3000)

doc.save("sheet.numbers")
```

### Editing paragraph styles

Cell text styles, known as paragraph styles, are those applied by the
Text tab in Numbers Format pane. To simplify the API, when writing
documents, it is not possible to make ad hoc changes to cells without
assigning an existing style or creating a new one. This differs to the
Numbers interface where cells can have modified styles on a per cell
basis. Such styles are read correctly when reading Numbers files.

Character styles, which allow formatting changes within cells such as
“This is **bold** text” are not supported.

Styles are created using the `Document`’s `add_style` method, and
can be applied to cells either as part of a `write` or using
`set_cell_style`:

```python
red_text = doc.add_style(
    name="Red Text",
    font_name="Lucida Grande",
    font_color=RGB(230, 25, 25),
    font_size=14.0,
    bold=True,
    italic=True,
    alignment=Alignment("right", "top"),
)
table.write("B2", "Red", style=red_text)
table.set_cell_style("C2", red_text)
```

New styles are automatically added to the list of styles selectable in
the Numbers Text pane.

Cell styles can also be referred to by name in both `Table.write` and
`Table.set_cell_style`. A `dict` of available styles is returned by
the `Document` property `styles`. This contains key value pairs of
style names and `Style` objects. Any changes to `Style` objects in
the document are written back such that those styles are changed for all
cells that use them.

```python
doc = Document("styles.numbers")
styles = doc.styles
styles["Title"].font_size = 20.0
```

Since `Style` objects are shared, changing `Cell.style.font_size`
will have the effect of changing the font size for that style and will
in turn affect the styles of all cells using that style.

# API

### *class* numbers_parser.Document(filename: str | None = None, sheet_name: str | None = 'Sheet 1', table_name: str | None = 'Table 1', num_header_rows: int | None = 1, num_header_cols: int | None = 1, num_rows: int | None = 12, num_cols: int | None = 8)

Create an instance of a new Numbers document.

If `filename` is `None`, an empty document is created using the defaults
defined by the class constructor. You can optionionally override these
defaults at object construction time.

* **Parameters:**
  * **filename** (`str` *optional*, default: `None`) – Apple Numbers document to read.
  * **sheet_name** (`str` *optional*, default: `'Sheet 1'`) – Name of the first sheet in a new document
  * **table_name** (`str` *optional*, default: `'Table 1'`) – Name of the first table in the first sheet of a new
  * **num_header_rows** (`int` *optional*, default: `1`) – Number of header rows in the first table of a new document.
  * **num_header_cols** (`int` *optional*, default: `1`) – Number of header columns in the first table of a new document.
  * **num_rows** (`int` *optional*, default: `12`) – Number of rows in the first table of a new document.
  * **num_cols** (`int` *optional*, default: `8`) – Number of columns in the first table of a new document.
* **Raises:**
  * **IndexError** – If the sheet name already exists in the document.
  * **IndexError** – If the table name already exists in the first sheet.

**Examples**

Reading a document and examining the `Tables` object:

```python
>>> from numbers_parser import Document
>>> doc = Document("mydoc.numbers")
>>> doc.sheets[0].name
'Sheet 1'
>>> table = doc.sheets[0].tables[0]
>>> table.name
'Table 1'
```

Creating a new document:

```python
doc = Document()
doc.add_sheet("New Sheet", "New Table")
sheet = doc.sheets["New Sheet"]
table = sheet.tables["New Table"]
table.write(1, 1, 1000)
table.write(1, 2, 2000)
table.write(1, 3, 3000)
doc.save("mydoc.numbers")
```

#### *property* sheets *: List[[Sheet](#numbers_parser.Sheet)]*

A list of sheets in the document.

* **Type:**
  List[[`Sheet`](#numbers_parser.Sheet)]

#### *property* styles *: Dict[str, Style]*

A dict mapping style names to to the corresponding style.

* **Type:**
  Dict[str, `Style`]

#### *property* custom_formats *: Dict[str, CustomFormatting]*

A dict mapping custom format names
to the corresponding custom format.

* **Type:**
  Dict[str, `CustomFormatting`]

#### save(filename: str)

Save the document in the specified filename.

* **Parameters:**
  **filename** (`str`) – The path to save the document to. If the file already exists,
  it will be overwritten.
* **Return type:**
  `None`

#### add_sheet(sheet_name: str | None = None, table_name: str | None = 'Table 1', num_rows: int | None = 12, num_cols: int | None = 8)

Add a new sheet to the current document.

If no sheet name is provided, the next available numbered sheet
will be generated in the series `Sheet 1`, `Sheet 2`, etc.

* **Parameters:**
  * **sheet_name** (`str` *optional*, default: `None`) – The name of the sheet to add to the document
  * **table_name** (`str` *optional*, default: `'Table 1'`) – The name of the table created in the new sheet
  * **num_rows** (`int` *optional*, default: `12`) – The number of columns in the newly created table
  * **num_cols** (`int` *optional*, default: `8`) – The number of columns in the newly created table
* **Raises:**
  **IndexError** – If the sheet name already exists in the document.
* **Return type:**
  `None`

#### add_style(\*\*kwargs)

Add a new style to the current document.

If no style name is provided, the next available numbered style will be generated.

* **Parameters:**
  * **\*\*kwargs** – style arguments
  * **style** (*Key-value pairs defining a cell*) – 
* **Style Keyword Arguments:**
  * *alignment* (**Alignment**): horizontal and vertical alignment of the cell
  * *bg_color* (**Union[RGB, List[RGB]]**): cell background color or list
    of colors for gradients
  * *bold* (**str**) : `True` if the cell font is bold
  * *font_color* (**RGB**) : font color
  * *font_size* (**float**) : font size in points
  * *font_name* (**str**) : font name
  * *italic* (**str**) : `True` if the cell font is italic
  * *name* (**str**) : cell style
  * *underline* (**str**) : `True` if the cell font is underline
  * *strikethrough* (**str**) : `True` if the cell font is strikethrough
  * *first_indent* (**float**) : first line indent in points
  * *left_indent* (**float**) : left indent in points
  * *right_indent* (**float**) : right indent in points
  * *text_inset* (**float**) : text inset in points
  * *text_wrap* (**str**) : `True` if text wrapping is enabled
* **Return type:**
  `Style`

```python
red_text = doc.add_style(
    name="Red Text",
    font_name="Lucida Grande",
    font_color=RGB(230, 25, 25),
    font_size=14.0,
    bold=True,
    italic=True,
    alignment=Alignment("right", "top"),
)
table.write("B2", "Red", style=red_text)
table.set_cell_style("C2", red_text)
```

#### add_custom_format(\*\*kwargs)

Add a new custom format to the current document.

If no format name is provided, the next available numbered format will be generated.

* **Parameters:**
  * **\*\*kwargs** – style arguments
  * **format** (*Key-value pairs defining a cell*) – 
* **Common Custom Formatting Keyword Arguments:**
  * *alignment* (**Alignment**): the horizontal and vertical alignment of the cell
  * *name* (**str**): the name of the custom format
    If no name is provided, one is generated using the scheme `Custom Format`,
    `Custom Format 1`, `Custom Format 2`, etc.
  * *type* (**str**): the type of format to create
    Supported formats are `number`, `datetime` and `text`. If no type is
    provided, `add_custom_format` defaults to `number`
* **Custom Formatting Keyword Arguments for type\`\`=\`\`number`type``=``number`:**
  * *integer_format* (**PaddingType**): how to pad integers, default `PaddingType.NONE`
  * *decimal_format* (**PaddingType**): how to pad decimals, default `PaddingType.NONE`
  * *num_integers* (**int**): integer precision when integers are padded, default 0
  * *num_decimals* (**int**): integer precision when decimals are padded, default 0
  * *show_thousands_separator* (**bool**): `True` if the number should include
    a thousands seperator
* **Custom Formatting Keyword Arguments for type\`\`=\`\`datetime`type``=``datetime`:**
  * *format* (**str**): a POSIX strftime-like formatting string
    See Date/time formatting for a list of supported directives, default `d MMM y`
* **Custom Formatting Keyword Arguments for type\`\`=\`\`text`type``=``text`:**
  * *format* (**str**): string format
    The cell value is inserted in place of %s. Only one substitution is allowed by
    Numbers, and multiple %s formatting references raise a TypeError exception
* **Return type:**
  `CustomFormatting`

### *class* numbers_parser.Sheet

Do not instantiate directly. Sheets are created by [`Document`](#numbers_parser.Document).

#### *property* tables *: List[[Table](#numbers_parser.Table)]*

A list of tables in the sheet.

* **Type:**
  List[[`Table`](#numbers_parser.Table)]

#### *property* name *: str*

The name of the sheet.

* **Type:**
  str

#### add_table(table_name: str | None = None, x: float | None = None, y: float | None = None, num_rows: int | None = 12, num_cols: int | None = 8)

Add a new table to the current sheet.

If no table name is provided, the next available numbered table
will be generated in the series `Table 1`, `Table 2`, etc.

By default, new tables are positioned at a fixed offset below the last
table vertically in a sheet and on the left side of the sheet. Large
table headers and captions may result in new tables overlapping existing
ones. The `add_table` method takes optional coordinates for
positioning a table. A table’s height and coordinates can also be
queried to help aligning new tables:

```python
(x, y) = sheet.table[0].coordinates
y += sheet.table[0].height + 200.0
new_table = sheet.add_table("Offset Table", x, y)
```

* **Parameters:**
  * **table_name** (`str` *optional*, default: `None`) – The name of the new table.
  * **x** (`float` *optional*, default: `None`) – The x offset for the table in points.
  * **y** (`float` *optional*, default: `None`) – The y offset for the table in points. If `None`, the table
    is placed below the last table in the sheet.
  * **num_rows** (`int` *optional*, default: `12`) – The number of rows for the new table.
  * **num_cols** (`int` *optional*, default: `8`) – The number of columns for the new table.
* **Returns:**
  the newly created table.
* **Return type:**
  [`Table`](#numbers_parser.Table)
* **Raises:**
  **IndexError** – If the table name already exists.

### *class* numbers_parser.Table

Do not instantiate directly. Tables are created by [`Document`](#numbers_parser.Document).

#### *property* name *: str*

The table’s name.

* **Type:**
  str

#### *property* table_name_enabled *: bool*

`True` if the table name is visible, `False` otherwise.

* **Type:**
  bool

#### *property* num_header_rows *: int*

The number of header rows.

* **Raises:**
  **ValueError** – If the number of headers is negative, exceeds the number of rows in the
      table, or exceeds Numbers maxinum number of headers (`MAX_HEADER_COUNT`).
* **Type:**
  int

#### *property* num_header_cols *: int*

The number of header columns.

* **Raises:**
  **ValueError** – If the number of headers is negative, exceeds the number of rows in the
      table, or exceeds Numbers maxinum number of headers (`MAX_HEADER_COUNT`).
* **Type:**
  int

#### *property* height *: int*

The table’s height in points.

* **Type:**
  int

#### *property* width *: int*

The table’s width in points.

* **Type:**
  int

#### row_height(row_num: int, height: int = None)

The height of a table row in points.

* **Parameters:**
  * **row_num** (`int`) – the zero-offset row number
  * **height** (`int`, default: `None`) – the height of the row in points. If not `None`, set the row height.
* **Returns:**
  The height of the table row.
* **Return type:**
  int

#### col_width(col_num: int, width: int = None)

The width of a table column in points.

* **Parameters:**
  * **col_num** (`int`) – the zero-offset column number
  * **width** (`int`, default: `None`) – the width of the column in points. If not `None`, set the column width.
* **Returns:**
  The width of the table column.
* **Return type:**
  int

#### *property* coordinates *: Tuple[float]*

The table’s x, y offsets in points.

* **Type:**
  Tuple[float]

#### rows(values_only: bool = False)

Return all rows of cells for the Table.

* **Parameters:**
  **values_only** (`bool`, default: `False`) – if `True`, return cell values instead of `Cell` objects
* **Returns:**
  list of rows; each row is a list
  : of Cell objects, or string values.
* **Return type:**
  Union[List[List[Cell]], List[List[str]]]

#### cell(\*args)

Return a single cell in the table.

Cell references in a table can be **row-column** offsers or Excel/Numbers-style **A1**
notation:

```python
(0, 0)      # Row-column notation.
("A1")      # The same cell in A1 notation.
```

Args (row-column notation):
: param1 (`int`): zero-indexed row number
  param2 (`int`): zero-indexed column number

Args (A1 notation):
: param1 (`str`): a cell reference using Excel/Numbers-style A1 notation.

* **Returns:**
  A cell with the base class `Cell` or, if merged, a `MergedCell`.
* **Return type:**
  Union[Cell, MergedCell]

**Merged cells**

`Cell.is_merged` returns `True` for any cell that is the result of
merging rows and/or columns. Cells eliminated from the table by the
merge can still be indexed using `Table.cell()` and are of type
`MergedCell`.

Consider this example:

<table>
    <tr>
        <td>A1</td>
        <td rowspan=2>B1</td>
    </tr>
    <tr>
        <td>A2</td>
    </tr>
</table>

The properties of merges are tested using the following properties:

| Cell   | Type       | `value`   | `is_merged`   | `size`   | `rect`       | `merge_range`   |
|--------|------------|-----------|---------------|----------|--------------|-----------------|
| A1     | TextCell   | `A1`      | `False`       | (1, 1)   | `None`       | `None`          |
| A2     | TextCell   | `A2`      | `False`       | (1, 1)   | `None`       | `None`          |
| B1     | TextCell   | `B1`      | `True`        | (2, 1)   | `None`       | `None`          |
| B2     | MergedCell | `None`    | `False`       | `None`   | (1, 0, 2, 0) | `"B1:B2"`       |

The tuple values of the `rect` property of a `MergedCell` are also
available using the properties `row_start`, `col_start`,
`row_end`, and `col_end`.

**Example**

```python
>>> doc = Document("mydoc.numbers")
>>> sheets = doc.sheets
>>> tables = sheets["Sheet 1"].tables
>>> table = tables["Table 1"]
>>> table.cell(1,0)
<numbers_parser.cell.TextCell object at 0x105a80a10>
>>> table.cell(1,0).value
'Debit'
>>> table.cell("B2")
<numbers_parser.cell.TextCell object at 0x105a80b90>
>>> table.cell("B2").value
1234.50
```

#### iter_rows(min_row: int | None = None, max_row: int | None = None, min_col: int | None = None, max_col: int | None = None, values_only: bool | None = False)

Produces cells from a table, by row.

Specify the iteration range using the indexes of the rows and columns.

* **Parameters:**
  * **min_row** (`int` *optional*, default: `None`) – Zero-indexed starting row number, or `0` if `None`.
  * **max_row** (`int` *optional*, default: `None`) – Zero-indexed end row number, or all rows if `None`.
  * **min_col** (`int` *optional*, default: `None`) – Zero-indexed starting column number or `0` if `None`.
  * **max_col** (`int` *optional*, default: `None`) – Zero-indexed end column number, or all columns if `None`.
  * **values_only** (`bool` *optional*, default: `False`) – return cell values rather than `Cell` objects
* **Yields:**
  *tuple* – `Cell` objects or string values for the row
* **Raises:**
  **IndexError** – If row or column values are out of range for the table
* **Return type:**
  `Generator`[`tuple`, `None`, `None`]

#### iter_cols(min_col: int | None = None, max_col: int | None = None, min_row: int | None = None, max_row: int | None = None, values_only: bool | None = False)

Produces cells from a table, by column.

Specify the iteration range using the indexes of the rows and columns.

* **Parameters:**
  * **min_col** (`int` *optional*, default: `None`) – Zero-indexed starting column number or `0` if `None`.
  * **max_col** (`int` *optional*, default: `None`) – Zero-indexed end column number, or all columns if `None`.
  * **min_row** (`int` *optional*, default: `None`) – Zero-indexed starting row number, or `0` if `None`.
  * **max_row** (`int` *optional*, default: `None`) – Zero-indexed end row number, or all rows if `None`.
  * **values_only** (`bool` *optional*, default: `False`) – return cell values rather than `Cell` objects
* **Yields:**
  *tuple* – `Cell` objects or string values for the row
* **Raises:**
  **IndexError** – If row or column values are out of range for the table
* **Return type:**
  `Generator`[`tuple`, `None`, `None`]

#### merge_cells(cell_range)

Convert a cell range or list of cell ranges into merged cells.

#### set_cell_formatting(\*args: str, \*\*kwargs)

Set the formatting for a cell.

* **Parameters:**
  **args** (`str`) – 
* **Return type:**
  `None`

## Command-line scripts

When installed from [PyPI](https://pypi.org/project/numbers-parser/),
a command-like script `cat-numbers` is installed in Python’s scripts
folder. This script dumps Numbers spreadsheets into Excel-compatible CSV
format, iterating through all the spreadsheets passed on the
command-line.

```text
usage: cat-numbers [-h] [-T | -S | -b] [-V] [--debug] [--formulas]
                   [--formatting] [-s SHEET] [-t TABLE] [document ...]

Export data from Apple Numbers spreadsheet tables

positional arguments:
  document                 Document(s) to export

optional arguments:
  -h, --help               show this help message and exit
  -T, --list-tables        List the names of tables and exit
  -S, --list-sheets        List the names of sheets and exit
  -b, --brief              Don't prefix data rows with name of sheet/table (default: false)
  -V, --version
  --debug                  Enable debug output
  --formulas               Dump formulas instead of formula results
  --formatting             Dump formatted cells (durations) as they appear in Numbers
  -s SHEET, --sheet SHEET  Names of sheet(s) to include in export
  -t TABLE, --table TABLE  Names of table(s) to include in export
```

Note: `--formatting` will return different capitalization for 12-hour
times due to differences between Numbers’ representation of these dates
and `datetime.strftime`. Numbers in English locales displays 12-hour
times with ‘am’ and ‘pm’, but `datetime.strftime` on macOS at least
cannot return lower-case versions of AM/PM.

## Numbers File Formats

Numbers uses a proprietary, compressed binary format to store its
tables. This format is comprised of a zip file containing images, as
well as [Snappy](https://github.com/google/snappy)-compressed
[Protobuf](https://github.com/protocolbuffers/protobuf) `.iwa`
files containing metadata, text, and all other definitions used in the
spreadsheet.

### Protobuf updates

As `numbers-parser` includes private Protobuf definitions extracted
from a copy of Numbers, new versions of Numbers will inevitably create
`.numbers` files that cannot be read by `numbers-parser`. As new
versions of Numbers are released, running `make bootstrap` will
perform all the steps necessary to recreate the protobuf files used
`numbers-parser` to read Numbers spreadsheets.

The default protobuf package installation may not include the C++
optimized version which is required by the bootstrapping scripts to
extract protobufs. You will receive the following error during build if
this is the case:

`This script requires the Protobuf installation to use the C++ implementation. Please reinstall Protobuf with C++ support.`

To include the C++ support, download a released version of Google
protobuf [from github](https://github.com/protocolbuffers/protobuf).
Build instructions are described in
``src/README.md` <[https://github.com/protocolbuffers/protobuf/blob/main/src/README](https://github.com/protocolbuffers/protobuf/blob/main/src/README)>\`_\_.These
have changed greatly over time, but as of April 2023, this was useful:

```shell
bazel build :protoc :protobuf
cmake . -DCMAKE_CXX_STANDARD=14
cmake --build . --parallel 8
export PROTOCOL_BUFFERS_PYTHON_IMPLEMENTATION=cpp
export LD_LIBRARY_PATH=../bazel-bin/src/google
cd python
python3 setup.py -q bdist_wheel --cpp_implementation --warnings_as_errors --compile_static_extension
```

This can then be used `make bootstrap` in the `numbers-parser`
source tree. The signing workflow assumes that you have an Apple
Developer Account and that you have created provisioning profile that
includes iCloud. Using a self-signed certificate does not seem to work,
at least on Apple Silicon (a working PR contradicting this is greatly
appreciated).

`make bootstrap` requires
[PyObjC](https://pypi.org/project/pyobjc/) to generate font maps, but
this dependency is excluded from Poetry to ensure that tests can run on
non-Mac OSes. You can run `poetry run pip install PyObjC` to get the
required packages.

## Credits

`numbers-parser` was built by [Jon
Connell](http://github.com/masaccio) but relies heavily on from
[prior work](https://github.com/psobot/keynote-parser) by [Peter
Sobot](https://petersobot.com) to read the IWA format archives used
by Apple’s iWork family of applications, and to regenerate the mapping
files required for Python. Both modules are derived from [previous
work](https://github.com/obriensp/iWorkFileFormat/blob/master/Docs/index.md)
by [Sean Patrick O’Brien](http://www.obriensp.com).

Decoding the data structures inside Numbers files was helped greatly by
[Stingray-Reader](https://github.com/slott56/Stingray-Reader) by
[Steven Lott](https://github.com/slott56).

Formula tests were adapted from JavaScript tests used in
[fast-formula-parser](https://github.com/LesterLyu/fast-formula-parser).

Decimal128 conversion to and from byte storage was adapted from work
done by the [SheetsJS project](https://github.com/SheetJS/sheetjs).
SheetJS also helped greatly with some of the steps required to
successfully save a Numbers spreadsheet.

## License

All code in this repository is licensed under the [MIT
License](https://github.com/masaccio/numbers-parser/blob/master/LICENSE.rst)
